[{"title":"二叉树的遍历","url":"/blog/2020/06/12/binary_tree_travel/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<p>二叉树的遍历题型:</p>\n<ol>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal\">二叉树的前序遍历</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal\">二叉树的中序遍历</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal\">二叉树的后序遍历</a></li>\n<li> <a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">二叉树的层次遍历</a></li>\n</ol>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal\">二叉树的前序遍历</a><br>  前序遍历的遍历顺序: 遍历根节点-&gt;左子树-&gt;右子树。<br>  遍历过程时间时遍历左右子树，根节点位置为读取数据。<br>  <strong>最左遍历法:</strong> 前序遍历左子树在前，所以遍历是先遍历左子树，由于根节点在左子树前，所以遍历左子树的同时，需要获取节点；直到遍历到左子树的叶节点，再遍历右子树【右子树的遍历也是先遍历完右子树的左子树】。<br>  遍历过程如图所示。<br><img src=\"https://github.com/hezhuhui/gallery/raw/master/leetcode/preorder.jpg\" alt=\"二叉树的前序遍历\"><br>大致过程为:<ol>\n<li>从根节点一直入栈，压到最左侧叶节点，节点压入栈的过程同时获取节点到ans数组。</li>\n<li>到左侧叶子节点后，切换右子树，再重复步骤1。</li>\n<li>直到压到右子树最后一个阶段。</li>\n<li>最后输出的ans即为前序遍历的结果。<br>代码如下:</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        if(root == null)&#123;</span><br><span class=\"line\">            return new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        while(!stack.isEmpty() || root != null)&#123;</span><br><span class=\"line\">            //左子树一直入栈，压到左叶子节点为止</span><br><span class=\"line\">while(root != null)&#123;</span><br><span class=\"line\">                stack.push(root); //节点入栈</span><br><span class=\"line\">                ans.add(root.val); //节点写入ans</span><br><span class=\"line\">                root = root.left; // 切换到左子树</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">//到达左叶子节点，切换到右子树</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal\">二叉树的中序遍历</a><br>中序遍历的顺序为:左子树-&gt;根节点-&gt;右子树，二叉树搜索树根据使用中序遍历，可以从小到大输出有序数组。<br>中序遍历遍历的数据的方式[最左遍历法]可以与前序遍历的方式一致，但是由于根节点输出位置在左子树之后。所有输出的根节点需要在出栈的过程。即左子树的左叶子最先直接输出。<br>遍历和输出过程如图所示:</li>\n</ul>\n<p><img src=\"https://github.com/hezhuhui/gallery/raw/master/leetcode/inorder.jpg\" alt=\"二叉树的中序遍历\"><br> 注意遍历方式与前序遍历一致，但是输出节点到ans的时机变为出栈时。<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">         if(root == null)&#123;</span><br><span class=\"line\">            return new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        while(!stack.isEmpty() || root != null)&#123;</span><br><span class=\"line\">            //先将最左压倒底</span><br><span class=\"line\">            while(root != null)&#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //切换到右子树</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            ans.add(root.val); //输出答案时机为出栈时</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal\">二叉树的后序遍历</a><br>后序遍历的遍历顺序为左子树-&gt;右子树-&gt;根节点，输出结果刚好与前序遍历相反。</li>\n<li><em>最右遍历法:</em>* 根节点需要在右子树之后，也就是可以通过先将右子树的右侧全部入栈，同时逆序排列，即可得到结果。<br>遍历过程如图所示。<br><img src=\"https://github.com/hezhuhui/gallery/raw/master/leetcode/postorder.jpg\" alt=\"二叉树的后序遍历\"><br>图中，先遍历右子树，且遍历过程中将节点输入到数组中，但是最后的结果需要逆序输出。也就是输出的结果为 4 5 2 1 6 2 1[序号的逆序输出]<br>实现代码如下:<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        if(root == null)&#123;</span><br><span class=\"line\">            return new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        while(!stack.isEmpty() || root != null)&#123;</span><br><span class=\"line\">            //遍历右子树，同时逆序排到输出结果中。</span><br><span class=\"line\">while(root != null)&#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                ans.addFirst(root.val);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">//最右侧节点为叶子节点后，切到左子树</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">            root = root.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n综上: 二叉树的前中后遍历可以总结为两种方法，最左和最右遍历法。其中中序遍历同时适用最左和最右遍历法。<br>所以前中后遍历二叉树关键是定义好两点:<br>1、使用的遍历的方法:最左/最右。<br>2、输出节点的时机。<br>3、输出的结果是否需要逆序。<br>通用代码模板如下:<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">         //base case</span><br><span class=\"line\">if(root == null)&#123;</span><br><span class=\"line\">            return new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        while(!stack.isEmpty() || root != null)&#123;</span><br><span class=\"line\">            //先将最左/最右压到叶子节点</span><br><span class=\"line\">            while(root != null)&#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">       //输出时机</span><br><span class=\"line\">       //如果是前序遍历使用最左输出，根节点位于左子树之前，所示先输出节点</span><br><span class=\"line\">       //如果中序遍历适用最左遍历，由于根节点位于左子树之后所以不能输出结果</span><br><span class=\"line\">       //如果后序遍历使用最右遍历，根节点位于右子树之后【理应先输出根节点】，由于逆序输出，变成了根节点可以先与右子树输出，所以此处需要输出节点</span><br><span class=\"line\">                //最左/最右输出，</span><br><span class=\"line\">       //如果是最左输出，需要节点一直为左子树根节点 root = root.left;</span><br><span class=\"line\">       //如果是最右输出，需要节点一直为右子树根节点 root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //切换到右子树</span><br><span class=\"line\">            root = stack.pop();</span><br><span class=\"line\">   //输出时机</span><br><span class=\"line\">   //根节点位于最左/最右之后，在此输出。因为可以形成从叶节点开始输出结果，得到先输出最左/最右的效果</span><br><span class=\"line\">            // ans.add(root.val); //输出答案时机为出栈时</span><br><span class=\"line\">           //切换时机</span><br><span class=\"line\">  //如果是最左，在此切换为右子树；如果是最右，则刚好相反</span><br><span class=\"line\">  root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>层次遍历 <a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/\">102</a> <a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">103</a> <a href=\"https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\">429</a><br>层次遍历与前中后序遍历不一样，本质上来说层次遍历是一种bfs，前中后遍历是一种dfs。dfs二叉树是往往是后进先出，即出栈一般是叶节点先出栈，再到非叶子节点直到树的根节点。然而bfs不同的是遍历需要从根节点开始，输出也是从根节点开始，所以是先进先出，所以一般使用队列来实现bfs。<br>二叉树的层次遍历代码模板:<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if(root == null)&#123;</span><br><span class=\"line\">            return ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while(!queue.isEmpty())&#123;</span><br><span class=\"line\">            //遍历一层的元素</span><br><span class=\"line\">            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">            int len = queue.size();</span><br><span class=\"line\">            //按层输出</span><br><span class=\"line\">            for(int i = 0; i &lt; len; i++)&#123;</span><br><span class=\"line\">                   // 每一层元素的出队队和入队的方向决定了层次遍历的规则</span><br><span class=\"line\">                   // 如果需要按照Z输出，需要添加判断条件，使得每一层入队和出队在队列的方向是相反的。</span><br><span class=\"line\">                   //同时注意，入队处不能作为出队处，否则会导致下一层的数据提前出队。</span><br><span class=\"line\">                   // 也就是入队和出队在同一处，会导致刚入队的数据[理应是下一层的数据]，就会立马出队，违反了先进先出原则。</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                if(node.left != null)&#123;</span><br><span class=\"line\">                    queue.offer(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(node.right != null)&#123;</span><br><span class=\"line\">                    queue.offer(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 list.add(node.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans.add(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]},{"title":"二叉树视图/节点求和问题","url":"/blog/2020/05/01/binary_tree_view/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<h2 id=\"问题分类\"><a href=\"#问题分类\" class=\"headerlink\" title=\"问题分类\"></a>问题分类</h2><ul>\n<li>左视图/右视图节点问题:求和/列出节点值</li>\n<li>左节点/右叶子节点问题:求和/列出节点值</li>\n<li>俯视图<h2 id=\"求解技巧\"><a href=\"#求解技巧\" class=\"headerlink\" title=\"求解技巧\"></a>求解技巧</h2></li>\n</ul>\n<ol>\n<li>左/右视图问题（以右视图为例：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">二叉树的右视图</a>）</li>\n</ol>\n<ul>\n<li>问题描述: 以右视图为例，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</li>\n<li>分析：<br><u>本质求二叉树每一层的最右边的节点</u>，可以使用bfs对二叉树进行从左到右层次遍历，取每一层最右边的节点加入列表。</li>\n<li>代码实现<br>通过层次遍历获取每一层数据的通用模板<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  public T readTree(TreeNode root) &#123;</span><br><span class=\"line\">        // base case</span><br><span class=\"line\">List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        if(root == null)&#123;</span><br><span class=\"line\">            return T;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">// 定义bfs使用的队列</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">// 先加入根节点</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while (!queue.isEmpty())&#123;</span><br><span class=\"line\">    // 求每一层节点的个数</span><br><span class=\"line\">            int size = queue.size();</span><br><span class=\"line\">    // 遍历每一层的节点</span><br><span class=\"line\">            for(int i = 0; i &lt; size; i++)&#123;</span><br><span class=\"line\">                TreeNode tmp = queue.poll();</span><br><span class=\"line\">        /**</span><br><span class=\"line\">        * 此处实现每一层的数据操作</span><br><span class=\"line\">        * 以右视图为例，此处可添加代码</span><br><span class=\"line\">        *  </span><br><span class=\"line\">            // 每一层最右边的节点加入结果集合</span><br><span class=\"line\">           if(i == size - 1)&#123;</span><br><span class=\"line\">                    ans.add(tmp.val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        **/</span><br><span class=\"line\">        //添加下一层数据到队列，从左往右添加</span><br><span class=\"line\">                if(tmp.left != null)&#123;</span><br><span class=\"line\">                    queue.offer(tmp.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(tmp.right != null)&#123;</span><br><span class=\"line\">                    queue.offer(tmp.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return T;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>左节点/右叶子节点问题：<a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">左叶子之和</a></li>\n</ol>\n<ul>\n<li>问题描述: 以求左叶子为例，题目要求获取所有左子树的叶子节点之和，不包含非叶子节点。</li>\n<li>分析: 注意与左视图问题区别：问题可以转化为求所有叶子节点中，左叶子之和。如果使用bfs，由于是层次遍历会导致左右子树的属性丢失，所有使用dfs遍历左子树和右子树，同时标记当前遍历处于哪个子树（通过参数标识）。</li>\n<li>代码实现<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    int sum = 0;</span><br><span class=\"line\">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class=\"line\">        if(root == null) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.left != null)&#123;</span><br><span class=\"line\">            dfs(root.left,true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.right != null)&#123;</span><br><span class=\"line\">            dfs(root.right,false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void dfs(TreeNode root,Boolean isLeft)&#123;</span><br><span class=\"line\">        // 该节点为叶子节点并且是左节点</span><br><span class=\"line\">        if(root.left == null &amp;&amp; root.right == null &amp;&amp; isLeft)&#123;</span><br><span class=\"line\">            sum += root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.left != null)&#123;</span><br><span class=\"line\">            dfs(root.left,true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.right != null)&#123;</span><br><span class=\"line\">            dfs(root.right,false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>俯视图</li>\n</ol>\n<ul>\n<li>问题描述:想象自身从二叉树的上方俯视二叉树，以根节点为界，列出根节点右侧的节点。</li>\n<li>分析:<ol>\n<li>从俯视图右侧的看到的节点，不一定为右子树节点，因为如果根节点的右子树为null，但是左子树一直往右偏移，可能越过根节点的正下方，从而出现在俯视图的根节点右侧。</li>\n<li>每一层的最右节点不一定为俯视图看到节点，因为如果上层的最右节点挡住了当前层的节点也就看不到当前节点了。</li>\n<li>根据以上分析，关键点：<strong>记录每一个节点相对于root节点的偏移量a，再根据偏移量a与当前结果数组大小比较，判断当前节点偏移量是否大于数组大小，如果大于表示当前节点偏移量不会被遮挡，否则会被遮挡。</strong></li>\n<li>由于偏移量a的获取，需要根据上一层偏移量的大小确定，也就是<strong>依赖纵向关系，所以使用dfs不能使用bfs</strong>。</li>\n</ol>\n</li>\n<li>代码实现<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class=\"line\">        if(root == null)&#123;</span><br><span class=\"line\">            return new ArrayList&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.add(root.val);</span><br><span class=\"line\">        if(root.left != null)&#123;</span><br><span class=\"line\">            dfs(root.left,  -1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.right != null )&#123;</span><br><span class=\"line\">            dfs(root.right,  1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //index为偏移量，向左偏移量-1，向右+1</span><br><span class=\"line\">    void dfs(TreeNode root, int index)&#123;</span><br><span class=\"line\">    // 当节点不为null，且不阻挡时，加入结果集合</span><br><span class=\"line\">        if(root != null &amp;&amp; index &gt;= ans.size())&#123;</span><br><span class=\"line\">            ans.add(root.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.left != null)&#123;</span><br><span class=\"line\">            dfs(root.left, index - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(root.right != null )&#123;</span><br><span class=\"line\">            dfs(root.right, index + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2></li>\n</ul>\n<p>1.bfs和dfs遍历二叉树的使用场景:</p>\n<ul>\n<li><strong>如果当前节点的属性依赖上一节点传递，则使用dfs</strong>。如需要依赖上一节点来确定当前节点是左节点/右节点或者节点相对根节点偏移量。</li>\n<li><strong>如果当前节点的属性依赖兄弟节点传递，则使用bfs</strong>。如需要确定当前节点位于该层的位置。</li>\n</ul>\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]},{"title":"根节点和stw","url":"/blog/2021/07/30/gc%20root&stw/","content":"<ul>\n<li> gc roots 有哪些？</li>\n</ul>\n<ol>\n<li>全局引用（静态变量或者常量的引用）</li>\n<li>执行上下文（局部变量表或者本地方法栈的变量表）</li>\n<li>跨代引用的对象，老年代对新生代的引用，记录在RSET中。</li>\n</ol>\n<ul>\n<li>什么是stw（stop the world）<br>stw指的是停顿所有的用户线程，然后进行进行可达性分析。</li>\n<li>什么情况下会出现stw</li>\n</ul>\n<ol>\n<li>枚举根节点时 必须stw</li>\n<li>整理内存碎片时 必须进行stw，也就是标记-整理算法必须stw</li>\n</ol>\n<ul>\n<li>可达性分析包含那几部分，哪些部分必须stw。<br>可达性分析可以分为枚举根节点和查找引用链两个步骤。<br>枚举根节点是可达性分析准确性的基础,枚举根节点必须准确，所以必须stw。<br>查找引用链是耗时最长的操作，但是可以和用户线程并发执行，不需要stw。</li>\n<li>rset是什么？<br>rememberset 是一种用于记录从非收集区到收集区的指针集合的数据结构。</li>\n<li>卡表、卡页和remenberset的区别和联系。</li>\n</ul>\n<ol>\n<li>rset记录了非收集区到收集区的指针集合，也就是非收集区到收集区的引用关系。但是具体实现rset是依靠卡表。</li>\n<li>一块内存可以分成若干个卡页，每一个卡页是否存在跨代引用，使用卡表来记录。如果存在跨代引用那么就是dirty。如图所示：<br><img src=\"http://assets.processon.com/chart_image/61c4bb1c1e085364150a2a38.png\" alt=\"卡表和卡页对应关系\"><br>垃圾回收时，只要筛选出卡表中 dirty的元素 即可获取到哪些卡页包含跨代引用，把这些卡页放到gc roots 中进行扫描。</li>\n</ol>\n<ul>\n<li>卡表元素如何维护呢？何时变dirty，谁来把他们变dirty？</li>\n<li>什么是伪共享，卡表是如何解决伪共享问题？<br>cpu的内存是以缓冲行为单位进行传输的，如果缓存行中多个数据频繁修改，会出现大量的缓冲回写，无效化和同步操作，导致效率变低。所以建议书写的代码具有局部性原理。<br>卡表如果每次写操作都更新，那么就会面临伪共享问题。如果在每次将卡表变脏前，先检查卡表是否为脏，只有不为脏的卡表才更新，可以降低伪共享的问题。</li>\n</ul>\n","categories":["编程语言"],"tags":["java"]},{"title":"线程安全与锁优化","url":"/blog/2020/07/04/lock/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ol>\n<li>线程安全概念：不管运行环境的调度或交替进行，最终的运行结果都是正确的。<br>共享数据的线程安全从强到弱的分类：<ul>\n<li>不可变性：对象被构造出来后，内部的状态不会改变。基本数据类型；普通对象不会改变，或者状态被final修饰，如String，枚举类</li>\n<li>绝对安全：不管运行环境如何，调用者不需要做额外的措施保护线程安全。</li>\n<li>相对安全：一般意义上说的线程安全，对对象的单独操作是线程安全的。如线程安全类HashTable，Vector（不是任意环境下线程安全，利用多线程同时查询和删除，会出现线程不安全，需要额外的措施保证线程安全）</li>\n<li>线程兼容：对象本身线程不安全，通过额外的措施可以保证线程安全。</li>\n<li>线程对立: 无论使用任何措施都不能保证线程安全，例如suspend()和resume()【都不会释放锁，可能导致死锁】。</li>\n</ul>\n</li>\n<li>线程安全的实现方式<ul>\n<li>互斥同步（synchronized悲观锁）:保证同一时刻只有一个线程访问共享数据，通过线程在同一个共享数据的互斥来实现线程之间的消息同步。<br>    synchronized的锁对象：如果入参是对象，那么就是改对象的reference类型。没有入参，那么就是修饰的实例方法或类方法的实例对象或class对象。<br>    synchronized的特性：可重入，不公平锁<br>因为访问对象或对象方法时，会获取对象的锁；如果无锁或者锁为当前线程，则锁计数器加1,，相反解锁时，计数器减1，为0时释放锁。如果获取对象锁失败，线程会阻塞等待。<br>由于计数器的存在，使得synchronized时可重入。<br>缺点：会导致线程阻塞和唤醒(切入内核态)存在性能问题</li>\n<li>非阻塞同步（CAS乐观锁）：先操作，如果冲突再补偿。</li>\n<li>*实现方式**：保证操作和冲突检测的操作是原子的，通过CAS实现。<br>CAS是CPU指令通过锁总线的方式来支持冲突检测，是直接操作CPU不需要通过操作系统也就是没有通过操作系统内核态和用户态的切换，所以效率会比互斥同步高。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</li>\n<li>*CAS的ABA问题**，通过对旧值添加版本号解决。</li>\n<li><em>CAS的缺点:</em>* 循环中，获取旧值，计算新值，再回写时，比较当前值和旧值是否一致，如果冲突很严重，会导致循环一致执行，降低效率。java可通过自适应自旋锁解决。</li>\n</ul>\n</li>\n<li>无同步方案：数据线程私有，不需要线程之间进行同步，可实现线程安全。<br>实现方式：<br> <strong>可重入代码:</strong> 数据均是外部传入<br> 线程本地存储：ThreadLocal，线程私有ThreadLoacalMap，key为ThreadLocal<T>.threalLocalHashCode,value为线程私有的值。<h2 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h2><ol>\n<li>自适应自旋锁<br>利用CAS实现，根据线程上一次获取改对象的锁的成功程度进行循环次数。如果上一次成功获取对象的锁，则进行更长时间的循环。<br>如果对象的锁，很少成功获取到，直接跳过CAS。</li>\n<li>锁消除<br>编译期堆数据流进行分析，发现该方法或对象不可能存在竞争，则会把锁消除。</li>\n<li>锁粗化<br>同一个对象零碎的加锁，会把锁范围扩到整个操作序列的外部。</li>\n<li>轻量级锁<ul>\n<li>将对象头的MarkWord拷贝到栈帧(Lock Record)中，</li>\n<li>然后利用CAS将MarkWord更新为指向栈帧(Lock Record), 然后标志位设为00(标识轻量锁)。<strong>如果更新失败，先检查MarkWord是否指向当前线程，是则直接进行同步块（先设置再判断是否为本线程）。</strong> </li>\n<li>MarkWork不是当前线程，则对象已被抢占，继续循环等待更新MarkWord，<em>超过2个线程竞争则升级为重量锁</em></li>\n</ul>\n</li>\n<li>偏向锁：如果对象被其他线程获取，则一直偏向该线程，不需要进行同步操作。<ul>\n<li>高效的原因是只需要进行一次偏向锁，访问对象时，发现是偏向锁而且指向当前线程，直接进入同步块。相比轻量锁少了一次对MarkWord进行更新的操作。</li>\n<li>操作步骤：<br>锁对象第一次被获取时，MarkWord的标志位设为01（偏向锁），使用CAS把线程ID记录到对象的MarkWord（注意不是拷贝MarkWord到线程，再设置指针，检测是否获取锁时，直接查看对象头即可，虚拟机不需要做任何的操作）。</li>\n<li><em>一旦另外一个线程获取锁，理解变成无锁（01）或者升级为轻量级锁（00）</em>*</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["java"],"tags":["java"]},{"title":"Mysql Online DDL 详解","url":"/blog/2022/07/12/online_ddl/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n\n<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在和DBA沟通前对alter table 不熟悉，导致沟通不顺畅。从本文可以了解到DDL的执行过程，评估执行DDL对线上的影响。</p>\n<h1 id=\"ALTER-TABLE\"><a href=\"#ALTER-TABLE\" class=\"headerlink\" title=\"ALTER TABLE\"></a><code>ALTER TABLE</code></h1><p>能够修改shechma的内容如下：</p>\n<ul>\n<li>添加或删除列(columns)</li>\n<li>创建或销毁索引(index)</li>\n<li>改变列的类型(type)</li>\n<li>重命名列或表名</li>\n<li>修改表的存储引擎(storage engine)或者备注(comment)<br>详细：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/alter-table.html\">https://dev.mysql.com/doc/refman/5.7/en/alter-table.html</a></li>\n</ul>\n<h1 id=\"新增列的DDL会阻塞DML\"><a href=\"#新增列的DDL会阻塞DML\" class=\"headerlink\" title=\"新增列的DDL会阻塞DML\"></a>新增列的DDL会阻塞DML</h1><p>列操作的DDL支持的一些行为，其中新增列「Adding a column」是支持In place， rebuild table，「某些条件下」允许并发DML，特别注意新增自增列并不知支持并发DML。因此，add column操作在某些条件下是会阻塞DML。<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html#online-ddl-column-operations\">详细的材料</a><br><img src=\"https://github.com/maidongcao/img/blob/master/online_ddl/online_ddl_allow_table.png?raw=true\" alt=\"功能表格\"></p>\n<ul>\n<li><p>下边做个实验，观察新增列对DML的影响。实验参考：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-performance.html\">https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-performance.html</a></p>\n<ol>\n<li>session1: 创建表，进行事务查后不提交事务，加MDL读锁<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=InnoDB;</span><br><span class=\"line\">mysql&gt; START TRANSACTION;</span><br><span class=\"line\">mysql&gt; SELECT * FROM t1;</span><br></pre></td></tr></table></figure></li>\n<li>session2 ：给表格t1新增列x， 此时DDL会被阻塞，加MDL写锁<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=NONE;</span><br></pre></td></tr></table></figure></li>\n<li>session3 ：查询表格的数据，语句也会被阻塞，加MDL读锁<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT * FROM t1;</span><br></pre></td></tr></table></figure></li>\n<li>session4: 查询当前执行的线程；会看到阻塞的原因<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW FULL PROCESSLIST;</span><br></pre></td></tr></table></figure>\n结果如图：<br><img src=\"https://github.com/maidongcao/img/blob/master/online_ddl/show_process_result.png?raw=true\" alt=\"执行结果\"></li>\n</ol>\n</li>\n<li><p>结论</p>\n<ol>\n<li>MDL写锁触发锁表，导致DDL和DML都会阻塞</li>\n<li>DDL过程中会持有MDL写锁，导致锁表</li>\n<li>DDL的执行时长决定了DML的阻塞时长，如果DDL执行时长，会阻塞后续的DML </li>\n</ol>\n</li>\n</ul>\n<h1 id=\"新增列DDL的执行过程\"><a href=\"#新增列DDL的执行过程\" class=\"headerlink\" title=\"新增列DDL的执行过程\"></a>新增列DDL的执行过程</h1><p>在mysql 5.5 之前新增列「<strong>copy方式：在服务器层执行</strong>」需要锁表并且时间比较长，mysql5.6后 新增列支持<strong>INPLACE方法「存储引擎层执行</strong>」，大幅度缩短了锁表的时</p>\n<h2 id=\"COPY和INPLACE\"><a href=\"#COPY和INPLACE\" class=\"headerlink\" title=\"COPY和INPLACE\"></a>COPY和INPLACE</h2><p>从mysql5.6开始使用online DDL对DDL的执行过程进行了优化，解决了早期版本MysqlDDL操作锁表的问题，能够保证DDL执行过程报纸读写，不影响数据库对外服务。</p>\n<ul>\n<li>5.7之前版本 Mysql执行DDL的主要算法<br>间。</li>\n</ul>\n<ol>\n<li>COPY：</li>\n</ol>\n<ul>\n<li>主要步骤：<ol>\n<li>创建与原表结构定义一致的临时表</li>\n<li>对原表加锁，不允许执行DML，但允许快照读</li>\n<li>在临时表执行DDL语句</li>\n<li>逐行拷贝原表数据到临时表</li>\n<li>原表和临时表进行RENAME操作，此时升级原表上的锁，不允许读写，直至完成RENAME。</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>需要将数据从原表拷贝到临时表，这个过程颇为耗时</li>\n<li>整个过程大部分时间会锁住原表，导致DDL过程数据表无法提供服务</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>INPLACE<br>INPLACE「InnoDB fast index creation」5.5之前只限于二级索引的创建和删除。</li>\n</ol>\n<ul>\n<li>主要步骤：<ol>\n<li>创建临时的frm文件；</li>\n<li>对原表加锁，不允许执行DML，但允许查询；</li>\n<li>根据聚集索引的顺序，构造新的索引项，按照顺序插入新索引页；</li>\n<li>升级原表上的锁，不允许读写操作；</li>\n<li>进行RENAME操作，替换原表的frm文件，完成DDL操作；</li>\n</ol>\n</li>\n<li>总结：<ol>\n<li>DDL过程加锁的粒度比较小</li>\n<li>直接操作底层frm文件，不需要新建临时表拷贝数据</li>\n</ol>\n</li>\n</ul>\n<ol start=\"3\">\n<li>COPY和INPLACE的区别<ul>\n<li>COPY需要建立临时表，逐行拷贝数据到临时表，而INPLACE是通过修改底层文件来实现DDL</li>\n<li>INPLACE的持有锁时间更短，对DML的并发性更好些</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"online-DDL-执行新增列过程\"><a href=\"#online-DDL-执行新增列过程\" class=\"headerlink\" title=\"online DDL 执行新增列过程\"></a>online DDL 执行新增列过程</h2><p><strong>由于目前线上使用的mysql 5.7，存储引擎为InnoDb，以下内容都基于这个版本讨论。</strong><br>参考文档：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html\">https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html</a></p>\n<p>上一节，我们看到了INPLACE的核心思想是通过操作mysql文件，降低IO操作和锁的粒度来降低MDL对DML的影响。mysql 5.7 的新增列操作也是使用INPLACE实现类似的操作。</p>\n<h3 id=\"INPLACE-分类\"><a href=\"#INPLACE-分类\" class=\"headerlink\" title=\"INPLACE 分类\"></a>INPLACE 分类</h3><table>\n<thead>\n<tr>\n<th>INPLACE执行方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rebuilds Table</td>\n<td>行记录格格式的修改，如字段的增、删、类型修改</td>\n</tr>\n<tr>\n<td>No-Rebuilds Table</td>\n<td>不涉及行记录格式的修改，如索引删除、字段名修改</td>\n</tr>\n</tbody></table>\n<h3 id=\"新增列的Online-DDL过程\"><a href=\"#新增列的Online-DDL过程\" class=\"headerlink\" title=\"新增列的Online DDL过程\"></a>新增列的Online DDL过程</h3><p>Online DDL主要有PREPARE(准备)、EXECUTE(执行)和COMMIT(提交)三个阶段，如下：</p>\n<ol>\n<li><p>PREPARE：此过程都是轻量操作，新增frm和ibd文件和一些初始化操作</p>\n<ul>\n<li><pre><code>**创建新的临时frm文件「表结构文件」**；\n</code></pre>\n</li>\n<li><pre><code>**持有EXCLUSIVE-MDL锁，禁止读写操作**；\n</code></pre>\n</li>\n<li><pre><code>根据ALTER类型，确定执行方式(copy,Online-Rebuilds,Online-No-Rebuilds)；\n</code></pre>\n</li>\n<li><pre><code> 更新数据字典的内存对象；\n</code></pre>\n</li>\n<li><pre><code> 分配row_log对象记录增量(Rebuilds需要)；\n</code></pre>\n</li>\n<li>  **生成新的临时ibd文件「数据文件」(Rebuilds需要)**。</li>\n</ul>\n</li>\n<li><p>EXECUTE：</p>\n<ul>\n<li><pre><code>**降级EXCLUSIVE-MDL锁，允许读写**；\n</code></pre>\n</li>\n<li><pre><code>**记录执行期间产生的DML增量到row_log中(Rebuilds需要)**；\n</code></pre>\n</li>\n<li><pre><code>扫描old_table的聚集索引中每一条记录record；\n</code></pre>\n</li>\n<li><pre><code>根据构造新表对应的索引项；\n</code></pre>\n</li>\n<li><pre><code>将构造的索引项插入sort_buffer块中；\n</code></pre>\n</li>\n<li><pre><code>将sort_buffer块插入到新的索引中；\n</code></pre>\n</li>\n<li><pre><code>**将row_log中的记录应用到新临时表中，应用到最后一个block**；\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>COMMIT：</p>\n<ul>\n<li><strong>升级到EXECLUSIVE-MDL锁，禁止事务读写</strong>；</li>\n<li>重做row_log中最后一部分的增量；</li>\n<li>提交事务，写InnoDB redo日志；</li>\n<li>更新InnoDB的数据字典表；</li>\n<li>修改统计信息；</li>\n<li><strong>RENAME临时的ibd和frm文件</strong>；</li>\n<li>执行变更完成。</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>概括<br>row_log记录了DDL执行期间产生的DML操作，这保证了变更期间表的并发性，通过以上过程可以看出在EXECUTE(执行)阶段表允许读写操作，操作记录在row_log中，在最后阶段应用到新表当中，保证了数据的完整性。<h2 id=\"原生Online-DDL的局限\"><a href=\"#原生Online-DDL的局限\" class=\"headerlink\" title=\"原生Online DDL的局限\"></a>原生Online DDL的局限</h2>原生Online DDL 实际上是在存储引擎层执行的，对存储引擎的类型有一定的要求，并且目前并不是所有的DDL都执行oneline DDL。某些DDL不支持online DDL，会出现较大的代价。<br>实际生产环境中，更多的是希望有一种方式能够适配所有存储引擎和DML和所有的DDL能够并发执行，所有业界一般是更多使用例如gh-host等中间件来实现服务器层的并发DDL。</li>\n</ul>\n<h1 id=\"gh-host执行DDL\"><a href=\"#gh-host执行DDL\" class=\"headerlink\" title=\"gh-host执行DDL\"></a>gh-host执行DDL</h1><p>  由于原生online DDL支持的DDL有限「限制了存储引擎，DDL类型等」，所以业界一般使用的是gh-host工具「实现服务器层的DML和DDL并发，使用所有的DDL和存储引擎」执行DDL</p>\n<h2 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h2><p>  <img src=\"https://github.com/maidongcao/img/blob/master/online_ddl/gh-ost-general-flow.png?raw=true\" alt=\"gh-host\"><br>      1. Gh-ost 在主库和从库建立临时表「ghost table」<br>      2. Gh-ost 消费从库的binlog「公司内部消费的是主库的binlog」<br>      3. 把binlog回放临时表，在此过程中也同时拷贝原表到从表「原生online dll是先全量拷贝再同步增量」<br>      4. cut-over：临时表和原表切换「此才会有阻塞」</p>\n<h2 id=\"cut-over-阻塞过程\"><a href=\"#cut-over-阻塞过程\" class=\"headerlink\" title=\"cut-over 阻塞过程\"></a>cut-over 阻塞过程</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>clinet session 1</th>\n<th>gh-ost session 1</th>\n<th>clinet session 2</th>\n<th>gh-ost session 2</th>\n<th>clinet session 3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time 1</td>\n<td>正常 DML</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Time 2</td>\n<td></td>\n<td>创建del表「回滚使用」锁原表锁del表</td>\n<td>SELECT &amp; DML 等待gh-ost session 1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Time 3</td>\n<td></td>\n<td></td>\n<td></td>\n<td>执行rename表交换</td>\n<td>SELECT &amp; DML 等待gh-ost session 1 锁</td>\n</tr>\n<tr>\n<td>Time 4</td>\n<td></td>\n<td>检测到gh-ost session 2 的rename sql，释放锁</td>\n<td>等待锁</td>\n<td>执行rename，完成表交换</td>\n<td>等待锁</td>\n</tr>\n<tr>\n<td>Time 5</td>\n<td></td>\n<td></td>\n<td>正常执行</td>\n<td></td>\n<td>正常执行</td>\n</tr>\n</tbody></table>\n<ol>\n<li>client session 1 执行DML，此时gh-ost尝试加表锁；如果client session 1的DML是大事务，会加锁等待，3s后未加锁成功，会DDL执行失败。</li>\n<li>创建del表、锁原表和锁del表，这个步骤会加表锁</li>\n<li>提交rename表操作和正常流量的DML都会等待步骤2的表锁</li>\n<li>步骤2释放锁的时机是检测到gh-ost有提交rename sql。此时释放表锁，rename sql优先持有表锁执行rename 操作，完成表交换「执行时间很短」。</li>\n<li>在步骤4「rename」执行过程中，其他的DML都在等待表锁，一旦rename完成，会继续获取锁继续执行DML操作</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>cut-over过程中，主要的耗时在gh-ost锁原表。此时如果正常的DML有大事务，会导致无法获取到表锁，导致失败</li>\n<li>gh-ost获取表锁前有大事务，不会影响正常的DML。因为此时gh-ost未获取锁。</li>\n<li>一旦gh-ost获取表锁，后续的DML都会锁等待，直到rename「获取锁优先级最高」完成才执行<h1 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h1></li>\n<li> online DDL下进行新增列会存在短暂的锁表。对于大表的表记录修改，建议在低峰期操作。</li>\n<li> 执行DDL前，先评估下DDL可能对业务产生的影响，确认影响方案，和DBA确认阻塞的影响范围。</li>\n<li>由于执行alter table 是需要拷贝数据的，建议多个alter table 合并成一条。</li>\n<li>执行DDL前需要保证有足够的磁盘空间</li>\n</ol>\n","categories":["mysql"],"tags":["mysql"]},{"title":"指针和值","url":"/blog/2021/07/24/pointer_value/","content":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"值和指针\"><a href=\"#值和指针\" class=\"headerlink\" title=\"值和指针\"></a>值和指针</h2><ul>\n<li>值的声明直接写类型即可，如int</li>\n<li>指针的声明需要在类型前加*，如 *int<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var v int = 1  // 开辟的一块空间，名字为v, 空间的值为1`</span><br><span class=\"line\">var p *int = &amp;v  // 获取v的地址存到名为p的内存空间，*int 指向int类型的指针</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"http://assets.processon.com/chart_image/6016be58e401fd15813cfba8.png?_=1636815032732\" alt=\"&amp;和*的操作关系\"></p>\n<h2 id=\"指针操作\"><a href=\"#指针操作\" class=\"headerlink\" title=\"指针操作\"></a>指针操作</h2><ul>\n<li>操作符&amp;(取址符) : 是返回该变量的内存地址</li>\n<li>操作符* (取值符) : 是返回该指针指向的变量的值, 同时也可以进行修改指针指向内存地址的值</li>\n<li><em>取地址操作符&amp;和取值操作符*是一对互补操作符</em>*<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func  TestGetAddAndVal(t *testing.T)  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 准备一个字符串类型</span><br><span class=\"line\">    var house = &quot;Malibu Point 10880, 90265&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对字符串取地址, ptr类型为*string</span><br><span class=\"line\">    ptr := &amp;house</span><br><span class=\"line\"></span><br><span class=\"line\">    // 打印ptr的类型</span><br><span class=\"line\">    fmt.Printf(&quot;ptr type: %T\\n&quot;, ptr)  // ptr type: *string</span><br><span class=\"line\"></span><br><span class=\"line\">    // 打印ptr的指针地址</span><br><span class=\"line\">    fmt.Printf(&quot;address: %p\\n&quot;, ptr) // address: 0xc0420401b0</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对指针进行取值操作</span><br><span class=\"line\">    value := *ptr</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取值后的类型</span><br><span class=\"line\">    fmt.Printf(&quot;value type: %T\\n&quot;, value) // value type: string</span><br><span class=\"line\"></span><br><span class=\"line\">    // 指针取值后就是指向变量的值</span><br><span class=\"line\">    fmt.Printf(&quot;value: %s\\n&quot;, value) // value: Malibu Point 10880, 90265</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"指针细节\"><a href=\"#指针细节\" class=\"headerlink\" title=\"指针细节\"></a>指针细节</h2><h3 id=\"指针赋值\"><a href=\"#指针赋值\" class=\"headerlink\" title=\"指针赋值\"></a>指针赋值</h3><p>  go 的函数和接受者都只有值传递方式，不存在引用传递。指针传递也是传递指针的地址</p>\n<p>  以数值交换为例</p>\n<ol>\n<li>使用多重赋值进行值交换<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func swap(a, b int) &#123;</span><br><span class=\"line\">    b, a = a, b</span><br><span class=\"line\">     fmt.Println(b, a)</span><br><span class=\"line\">         fmt.Println(&amp;b, &amp;a) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x, y := 1, 2</span><br><span class=\"line\">    swap(x, y)</span><br><span class=\"line\">    fmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>交换指针<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func swap(a, b *int) &#123;</span><br><span class=\"line\">    b, a = a, b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x, y := 1, 2</span><br><span class=\"line\">    swap(&amp;x, &amp;y)</span><br><span class=\"line\">    fmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接受者指针和值\"><a href=\"#接受者指针和值\" class=\"headerlink\" title=\"接受者指针和值\"></a>接受者指针和值</h2>指针不仅可以作为函数的入参和返回值，也可以作为接受者<br>接收者可以为指针和值，指针会拷贝指针地址给到接收者，值会重新拷贝值给到接收者<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package pointer</span><br><span class=\"line\"></span><br><span class=\"line\">type Project struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Project) printVal() &#123;</span><br><span class=\"line\">    // 拷贝一个新的Project给p，不省内存</span><br><span class=\"line\">    fmt.Printf(&quot;p: type:%T, add:%p\\n&quot;, p, &amp;p) // 地址和origin 不一样</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p *Project) printProinter() &#123;</span><br><span class=\"line\">    // 拷贝一个新的地址给p</span><br><span class=\"line\">    fmt.Printf(&quot;p: type:%T, add:%p\\n&quot;, p, p) // 地址和origin 一样</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func TestReceiver(t *testing.T) &#123;</span><br><span class=\"line\">    p := Project&#123;&#125;</span><br><span class=\"line\">    fmt.Printf(&quot;origin p: type:%T, add:%p\\n&quot;, p, &amp;p)</span><br><span class=\"line\">    p.printVal()</span><br><span class=\"line\">    p.printProinter()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li> 指针接收者节省内存，，结构体很大时，性能比较好，应用运行通过指针修改变量的场景</li>\n<li>值接收者可以实现每个接收者都是全新的拷贝，可以实现不可变型的变量，提高代码的安全性，但是占用内存比较高</li>\n</ul>\n<h2 id=\"实现不可变型结构体\"><a href=\"#实现不可变型结构体\" class=\"headerlink\" title=\"实现不可变型结构体\"></a>实现不可变型结构体</h2><p>由于go值传递的特性，通过设置接收者的可见性为包内，并且通过值作为接受者进行拷贝新的值来实现不可变。废话不多说，直接上代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 指针 -&gt; 修改原来地址的值</span><br><span class=\"line\">// 值 -&gt; 没法修改原来地址的值</span><br><span class=\"line\">// 不可变型: 值一旦被创建就无法被改变对象,修改通过生成一个新的对象来实现</span><br><span class=\"line\">type Person struct &#123;</span><br><span class=\"line\">    name           string // 包内可见，避免被修改</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Person) WithName(newname string) Person &#123; // 拷贝新的结构体，返回新的结构体</span><br><span class=\"line\">    p.name = newname</span><br><span class=\"line\">    fmt.Printf(&quot;WithName p&#x27;s add:%p\\n&quot;, &amp;p) // 打印地址 0xc000064540</span><br><span class=\"line\">    return p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Person) Name() string &#123; // getter</span><br><span class=\"line\">    return p.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 值接收者实现不可变型</span><br><span class=\"line\">func TestImmutableForm(t *testing.T) &#123;</span><br><span class=\"line\">    me := Person&#123;&#125; // 默认初始化</span><br><span class=\"line\">    fmt.Printf(&quot;me data:%+#v\\n&quot;, me.Name())</span><br><span class=\"line\">    fmt.Printf(&quot;add:%p, data:%+#v\\n&quot;, &amp;me, me) // 0xc0000644e0</span><br><span class=\"line\">    m2 := me.WithName(&quot;Elliot&quot;)</span><br><span class=\"line\">    m2.Name()</span><br><span class=\"line\">    fmt.Printf(&quot;m2 data:%+#v\\n&quot;, m2.Name())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["编程语言"],"tags":["golang"]},{"title":"redis持久化","url":"/blog/2021/07/26/redis_durability/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>因为redis是内存数据库，一旦服务器进程退出，那么内存的数据将会销毁。为了保存redis的内存数据，就需要一种将内存落盘的持久化手段，服务器重启后能够加载落盘后的数据来恢复服务器的状态。<br>持久化的方式有RDB[快照]和AOF[日志追加]两种。</p>\n<h2 id=\"RDB–快照文件-恢复时间快但丢失数据多\"><a href=\"#RDB–快照文件-恢复时间快但丢失数据多\" class=\"headerlink\" title=\"RDB–快照文件(恢复时间快但丢失数据多)\"></a>RDB–快照文件(恢复时间快但丢失数据多)</h2><h3 id=\"创建RDB文件–SAVE和BGSAVE\"><a href=\"#创建RDB文件–SAVE和BGSAVE\" class=\"headerlink\" title=\"创建RDB文件–SAVE和BGSAVE\"></a>创建RDB文件–SAVE和BGSAVE</h3><ol>\n<li>为了防止生成RDB过程中，写入的数据干扰RDB的生成。</li>\n</ol>\n<p><strong>SAVE 保存EDB过程会阻塞主进程，BGSAVE通过fork子进程，父进程正常工作。</strong><br>bgsave命令的运作流程，如下所示。</p>\n<pre class=\"mermaid\">graph TD\nA[BGSAVE] -->|1| B(父进程)\nB --> H(有其他子进程正在执行 直接返回)\nB --> |2|C(fork 父进程会阻塞)\nC -->|3| D[响应其他命令]\nC -->E[子进程]\nE -->|4| F[生成RDB默认使用LZF进行压缩]\nE -->|5通知父进程| B</pre>\n<p>RDB文件可以落盘或者通过网络发生给其他节点进行复制。</p>\n<ul>\n<li>在执行BGSAVE期间，服务器处理SAVE，BGSAVE和REWRITEAOF的命令与平时不同<ol>\n<li>执行BGSAVE期间，执行SAVE和BGSAVE是会被拒绝的。因为父进程和子进程之间存在竞争条件。</li>\n<li>BGSAVE和REWRITEAOF的命令不能同时执行。如果BGSAVE先执行，那么REWRITEAOF会延时。放过来，BGSAVE会被拒绝。<h3 id=\"加载RDB文件\"><a href=\"#加载RDB文件\" class=\"headerlink\" title=\"加载RDB文件\"></a>加载RDB文件</h3>服务器载入文件的流程，如下所示<pre class=\"mermaid\">graph TD\nA[服务器启动] -->B[执行载入程序]\nB --> C{已开启AOF持久化功能}\nC -->|是| D[载入AOF]\nC -->|否| E[载入RDB文件]</pre>\n<h3 id=\"RDB的优缺点\"><a href=\"#RDB的优缺点\" class=\"headerlink\" title=\"RDB的优缺点\"></a>RDB的优缺点</h3></li>\n</ol>\n</li>\n<li>优点</li>\n</ul>\n<ol>\n<li> RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>\n<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>\n</ol>\n<ul>\n<li>缺点</li>\n</ul>\n<ol>\n<li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>\n<li> RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。？？？ 有哪些格式<h2 id=\"AOF–独立日志方式\"><a href=\"#AOF–独立日志方式\" class=\"headerlink\" title=\"AOF–独立日志方式\"></a>AOF–独立日志方式</h2>AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。主要解决数据持久化的实时性问题。<h3 id=\"AOF的工作流程\"><a href=\"#AOF的工作流程\" class=\"headerlink\" title=\"AOF的工作流程\"></a>AOF的工作流程</h3>AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载。</li>\n</ol>\n<pre class=\"mermaid\">graph TD\nA[命令写入] -->|1apend:使用文本协议| B(AOF缓冲区)\nB --> |2sync| C[AOF文件]\nC --> |重写| C\nD[重启] --> |load| C</pre>\n\n<ul>\n<li>为什么命令写到AOF缓冲区，而不是直接写入到AOF文件?<ol>\n<li>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。</li>\n<li>写入缓冲区，redis就可以提供多种同步磁盘策略，也就是落盘的方案选择可以有多种。</li>\n</ol>\n</li>\n<li>AOF缓冲区同步策略有哪些？<ol>\n<li>always: 命令写入缓冲区后，立马同步硬盘。</li>\n<li>everysec: 每秒同步一次缓冲区。</li>\n<li>no: 有操作系统策略进行同步。</li>\n</ol>\n</li>\n<li>为什么需要重写？解决了什么问题？<br>AOF是通过保存写命令来记录数据库的状态，但是随着写入的命令增多，文件的体积就会越来越大。AOF文件过大会造成影响redis和宿主机的性能，并且过大的AOF文件还原需要的时间也就越多。重写通过构造某个时刻数据库的状态的写入语句来减少AOF的命令数目，从而实现压缩AOF的目的。</li>\n<li>重写的原理是什么？<br> AOF的重写<strong>不是对旧的AOF文件进行读取、分析或者写入操作，而是通过读取当前数据库的状态来实现的。</strong><br> 假如使用了3条命令分别写入了键为key的， value分别为a b c的list，AOF的重写就是读取当前数据库的状态，重写的命令为1条 写入 key a b c的命令。<br> 总之，首先从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</li>\n<li>redis是单线程的，AOF重写如何防止阻塞主进程呢？<br>AOF的重写是后台进行的。<ol>\n<li>发起AOF重写时，会在父进程fork子进程来进行重写，同时创建AOF重写缓冲区。</li>\n<li>重写后的命令会写入AOF重写缓冲区。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"mermaid\">sequenceDiagram\n客户端->>命令处理器: 发送命令\n命令处理器-->>AOF缓冲区: 追加命令\n命令处理器-->>AOF重写缓冲区: 追加命令</pre>\n<pre><code>3. 新写入的命令，父进程处理后，会同时写入AOF缓冲区和AOF重写缓冲区，防止重写AOF时，导致数据不一致的问题。\n4. 但子进程完成AOF重写后，会向父进程发生信号。\n5. 父进程此时会阻塞客户端的命令，来将重写后的AOF更替成就的AOF.首先将AOF重缓冲区写入新的AOF文件，然后将AOF进行改名并覆盖旧的AOF.\n</code></pre>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>使用A服务器的客户端输入:SLAVEOF B{IP:端口} 那么A就是变成B的从服务器，B的数据也会同步到A中。也就是主服务器B会同步数据给从服务器A。<br>新版的主从复制包括完全重同步和部分重同步，旧版的主从复制只有完全重同步。<br>  <strong>旧版的主从复制，如果网络闪断会进行一次完全的同步，会消耗大量的资源，导致同步时间变长。</strong><br>  完全重同步：主要用于初次进行主从复制或者长时间断联后重新同步。主服务生成RDB文件，同时将启动生成RDB文件后的命令写入缓冲区。RDB生成后发生给从服务器，等RDB被从服务器加载完后，再将缓冲区命令发给从服务器。<br>  部分重同步:主要用于网络闪断的同步恢复。从服务断联后，重新连上到主服务，如果条件允许（数据偏移量相差在一定范围），主服务会把断联期间的数据发生给从服务进行同步。</p>\n<ul>\n<li>完全重同步跟旧版的复制功能几乎一样，如图。</li>\n</ul>\n<pre class=\"mermaid\">sequenceDiagram\n从服务器->>主服务器: 发送SYNC\n主服务器-->>从服务器: 发送RDB\n主服务器-->>从服务器: 发送缓冲区保持的所有命令</pre>\n\n<ul>\n<li>部分重同步<br>部分重同步主要以3部分组件实现：<pre><code>1. 主服务器和从服务器的复制偏移量，用于检查主从服务器是否一致，从服务器是每秒发生一次心跳给主服务器同步偏移量。\n</code></pre>\n<ol start=\"2\">\n<li>主服务器的复制积压缓冲区（默认为1M），主服务器的每条写命令都会写入复制缓冲区和从服务器。</li>\n<li>服务器的运行ID。</li>\n</ol>\n</li>\n<li>部分重同步实现步骤：    1. 每次主服务器向从服务器发生写命令时，会同步数据偏移量，并把写命令写入复制积压缓冲区。    2. 从服务器断联后，一段时间重新连接上主服务器，会向主服务发生PSYNC并报告自己的数据偏移量。    3. 主服务器收到从服务器的偏移量，计算目前积压缓冲区的偏移能否可以完成从服务器的同步，如果不可以那么就会进行完全同步，如果可以，就把积压缓冲区的命令发送给从服务器。</li>\n</ul>\n<ol start=\"4\">\n<li>从服务同步完数据后，更新偏移量。<h3 id=\"PSYNC的工作流程\"><a href=\"#PSYNC的工作流程\" class=\"headerlink\" title=\"PSYNC的工作流程\"></a>PSYNC的工作流程</h3></li>\n</ol>\n<pre class=\"mermaid\">graph TD\nA[从服务器接到客户端发来的SLAVEOF命令] -->B{首次复制}\nB --> |Y|C[向主服务器发送PSYNC?-1]\nB --> |N|D[向主服务器发送PSYNC <RUNID> <OFFSET>]\nC -->E[主服务器返回+FULLRESYNC<RUNID><OFFSET>执行完全重同步]\nD --> F{主服务器返回+continue}\nF -->|N| E\nF -->|Y|G[执行部分重同步]</pre>\n\n\n<h3 id=\"主从复制过程中对过期的键的处理\"><a href=\"#主从复制过程中对过期的键的处理\" class=\"headerlink\" title=\"主从复制过程中对过期的键的处理\"></a>主从复制过程中对过期的键的处理</h3><p> 主从服务过程过期键的处理有特别的方式。<strong>注意从服务器是无法自行删除过期键的，必须由主服务器触发，其实从服务器触发了惰性删除也不会执行，这样为了保持主从的一致性</strong>，以下讲述，生成和加载RDB和AOF过程的过期键处理方式。</p>\n<ol>\n<li>生成RDB–子进程进行<ul>\n<li>redis会对数据库的键进行检查，过期键不会生成RDB</li>\n</ul>\n</li>\n<li>载入RDB–是否容忍键检查的时间开销</li>\n</ol>\n<ul>\n<li>如果是主服务加载RDB，那么会对键进行检查，过期键不会加载到RDB。</li>\n<li>如果服务是从服务器，从服务器不管是否RDB是否有过期键，都会加载到武器。</li>\n</ul>\n<ol start=\"3\">\n<li>生成AOF–是否容忍键检查的时间开销</li>\n</ol>\n<ul>\n<li>如果数据库中存在已经过期的键，但是未被惰性或定期删除，那么也会这些过期的键也会生成到AOF文件中。</li>\n<li>如果键被过期了，且触发了删除操作，那么AOF也会追加删除命令。</li>\n</ul>\n<ol start=\"4\">\n<li>AFO重写–子进程进行</li>\n</ol>\n<ul>\n<li> AOF重写会校验过期的键，不会写入到重写的AOF中。<br>总之, 主服务器生成或加载RDB时，会忽略过期的键，因为主服务是通过子进程生成RDB的，由生成方保证数据的最新对redis服务器影响最小，并且主服务加载RDB一般是服务启动时，可以检查键过期，导致等待时间长不会造成功能问题；从服务器为了提高RDB的加载效率，尽快地进行数据同步，例如长时间断联后，进行完成重同步不能等待太久，所有不会对键的过期进行检查，直接加载RDB。生成AOF的频率比极高，不允许频繁检查键是否过期，所有会直接加载数据库的数据。AOF重写是在子进程操作，对父进程影响小，而且是进行优化目录来重写的，所有允许进行检查键是否过期。</li>\n<li>一言蔽之，<strong>复制过程中，是否进行键检查，取决于操作是否在子进程进行， 是否能容忍长时间的检查操作。</strong></li>\n</ul>\n","categories":["redis"],"tags":["redis"]},{"title":"滑动窗口解法","url":"/blog/2020/04/06/slide_window/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ol>\n<li>线程安全概念：不管运行环境的调度或交替进行，最终的运行结果都是正确的。<br>共享数据的线程安全从强到弱的分类：<ul>\n<li>不可变性：对象被构造出来后，内部的状态不会改变。基本数据类型；普通对象不会改变，或者状态被final修饰，如String，枚举类</li>\n<li>绝对安全：不管运行环境如何，调用者不需要做额外的措施保护线程安全。</li>\n<li>相对安全：一般意义上说的线程安全，对对象的单独操作是线程安全的。如线程安全类HashTable，Vector（不是任意环境下线程安全，利用多线程同时查询和删除，会出现线程不安全，需要额外的措施保证线程安全）</li>\n<li>线程兼容：对象本身线程不安全，通过额外的措施可以保证线程安全。</li>\n<li>线程对立: 无论使用任何措施都不能保证线程安全，例如suspend()和resume()【都不会释放锁，可能导致死锁】。</li>\n</ul>\n</li>\n<li>线程安全的实现方式<ul>\n<li>互斥同步（synchronized悲观锁）:保证同一时刻只有一个线程访问共享数据，通过线程在同一个共享数据的互斥来实现线程之间的消息同步。<br>    synchronized的锁对象：如果入参是对象，那么就是改对象的reference类型。没有入参，那么就是修饰的实例方法或类方法的实例对象或class对象。<br>    synchronized的特性：可重入，不公平锁<br>因为访问对象或对象方法时，会获取对象的锁；如果无锁或者锁为当前线程，则锁计数器加1,，相反解锁时，计数器减1，为0时释放锁。如果获取对象锁失败，线程会阻塞等待。<br>由于计数器的存在，使得synchronized时可重入。<br>缺点：会导致线程阻塞和唤醒(切入内核态)存在性能问题</li>\n<li>非阻塞同步（CAS乐观锁）：先操作，如果冲突再补偿。</li>\n<li>*实现方式**：保证操作和冲突检测的操作是原子的，通过CAS实现。<br>CAS是CPU指令通过锁总线的方式来支持冲突检测，是直接操作CPU不需要通过操作系统也就是没有通过操作系统内核态和用户态的切换，所以效率会比互斥同步高。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</li>\n<li>*CAS的ABA问题**，通过对旧值添加版本号解决。</li>\n<li><em>CAS的缺点:</em>* 循环中，获取旧值，计算新值，再回写时，比较当前值和旧值是否一致，如果冲突很严重，会导致循环一致执行，降低效率。java可通过自适应自旋锁解决。</li>\n</ul>\n</li>\n<li>无同步方案：数据线程私有，不需要线程之间进行同步，可实现线程安全。<br>实现方式：<br> <strong>可重入代码:</strong> 数据均是外部传入<br> 线程本地存储：ThreadLocal，线程私有ThreadLoacalMap，key为ThreadLocal<T>.threalLocalHashCode,value为线程私有的值。<h2 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h2><ol>\n<li>自适应自旋锁<br>利用CAS实现，根据线程上一次获取改对象的锁的成功程度进行循环次数。如果上一次成功获取对象的锁，则进行更长时间的循环。<br>如果对象的锁，很少成功获取到，直接跳过CAS。</li>\n<li>锁消除<br>编译期堆数据流进行分析，发现该方法或对象不可能存在竞争，则会把锁消除。</li>\n<li>锁粗化<br>同一个对象零碎的加锁，会把锁范围扩到整个操作序列的外部。</li>\n<li>轻量级锁<ul>\n<li>将对象头的MarkWord拷贝到栈帧(Lock Record)中，</li>\n<li>然后利用CAS将MarkWord更新为指向栈帧(Lock Record), 然后标志位设为00(标识轻量锁)。<strong>如果更新失败，先检查MarkWord是否指向当前线程，是则直接进行同步块（先设置再判断是否为本线程）。</strong> </li>\n<li>MarkWork不是当前线程，则对象已被抢占，继续循环等待更新MarkWord，<em>超过2个线程竞争则升级为重量锁</em></li>\n</ul>\n</li>\n<li>偏向锁：如果对象被其他线程获取，则一直偏向该线程，不需要进行同步操作。<ul>\n<li>高效的原因是只需要进行一次偏向锁，访问对象时，发现是偏向锁而且指向当前线程，直接进入同步块。相比轻量锁少了一次对MarkWord进行更新的操作。</li>\n<li>操作步骤：<br>锁对象第一次被获取时，MarkWord的标志位设为01（偏向锁），使用CAS把线程ID记录到对象的MarkWord（注意不是拷贝MarkWord到线程，再设置指针，检测是否获取锁时，直接查看对象头即可，虚拟机不需要做任何的操作）。</li>\n<li><em>一旦另外一个线程获取锁，理解变成无锁（01）或者升级为轻量级锁（00）</em>*</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]}]