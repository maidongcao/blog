[{"title":"指针和值","url":"/blog/2021/07/24/pointer_value/","content":"# 指针\n## 值和指针\n值的声明直接写类型即可，如int\n指针的声明需要在类型前加*，如*int\n```\n`var v int = 1  // 开辟的一块空间，名字为v, 空间的值为1`\nvar p *int = &v  // 获取v的地址存到名为p的内存空间，*int 指向int类型的指针\n```\n![&和*的操作关系](http://assets.processon.com/chart_image/6016be58e401fd15813cfba8.png?_=1636815032732)\n## 指针操作\n* 操作符&(取址符) : 是返回该变量的内存地址\n* 操作符* (取值符) : 是返回该指针指向的变量的值, 同时也可以进行修改指针指向内存地址的值\n**取地址操作符&和取值操作符\\*是一对互补操作符**\n````\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc  TestGetAddAndVal(t *testing.T)  {\n\n    // 准备一个字符串类型\n    var house = \"Malibu Point 10880, 90265\"\n\n    // 对字符串取地址, ptr类型为*string\n    ptr := &house\n\n    // 打印ptr的类型\n    fmt.Printf(\"ptr type: %T\\n\", ptr)  // ptr type: *string\n\n    // 打印ptr的指针地址\n    fmt.Printf(\"address: %p\\n\", ptr) // address: 0xc0420401b0\n\n    // 对指针进行取值操作\n    value := *ptr\n\n    // 取值后的类型\n    fmt.Printf(\"value type: %T\\n\", value) // value type: string\n\n    // 指针取值后就是指向变量的值\n    fmt.Printf(\"value: %s\\n\", value) // value: Malibu Point 10880, 90265\n\n}\n````\n## 指针细节\n### 指针 赋值\n\ngo 的函数和接受者都只有值传递方式，不存在引用传递。指针传递也是传递指针的地址\n以数值交换为例\n1. 使用多重赋值进行值交换\n```\npackage main\n\nimport \"fmt\"\n\nfunc swap(a, b int) {\n    b, a = a, b\n     fmt.Println(b, a)\n         fmt.Println(&b, &a) \n}\n\nfunc main() {\n    x, y := 1, 2\n    swap(x, y)\n    fmt.Println(x, y)\n}\n```\n2. 交换指针\n```\n\npackage main\n\nimport \"fmt\"\n\nfunc swap(a, b *int) {\n    b, a = a, b\n}\n\nfunc main() {\n    x, y := 1, 2\n    swap(&x, &y)\n    fmt.Println(x, y)\n}\n```\n## 接受者指针和值\n指针不仅可以作为函数的入参和返回值，也可以作为接受者\n接收者可以为指针和值，指针会拷贝指针地址给到接收者，值会重新拷贝值给到接收者\n```\npackage pointer\n\ntype Project struct {\n    Code int\n}\nfunc (p Project) printVal() {\n    // 拷贝一个新的Project给p，不省内存\n    fmt.Printf(\"p: type:%T, add:%p\\n\", p, &p) // 地址和origin 不一样\n}\nfunc (p *Project) printProinter() {\n    // 拷贝一个新的地址给p\n    fmt.Printf(\"p: type:%T, add:%p\\n\", p, p) // 地址和origin 一样\n}\nfunc TestReceiver(t *testing.T) {\n    p := Project{}\n    fmt.Printf(\"origin p: type:%T, add:%p\\n\", p, &p)\n    p.printVal()\n    p.printProinter()\n}\n```\n*  指针接收者节省内存，，结构体很大时，性能比较好，应用运行通过指针修改变量的场景\n* 值接收者可以实现每个接收者都是全新的拷贝，可以实现不可变型的变量，提高代码的安全性，但是占用内存比较高\n\n## 实现不可变型结构体\n由于go值传递的特性，通过设置接收者的可见性为包内，并且通过值作为接受者进行拷贝新的值来实现不可变。废话不多说，直接上代码\n```\n\n// 指针 -> 修改原来地址的值\n// 值 -> 没法修改原来地址的值\n// 不可变型: 值一旦被创建就无法被改变对象,修改通过生成一个新的对象来实现\ntype Person struct {\n    name           string // 包内可见，避免被修改\n}\nfunc (p Person) WithName(newname string) Person { // 拷贝新的结构体，返回新的结构体\n    p.name = newname\n    fmt.Printf(\"WithName p's add:%p\\n\", &p) // 打印地址 0xc000064540\n    return p\n}\nfunc (p Person) Name() string { // getter\n    return p.name\n}\n// 值接收者实现不可变型\nfunc TestImmutableForm(t *testing.T) {\n    me := Person{} // 默认初始化\n    fmt.Printf(\"me data:%+#v\\n\", me.Name())\n    fmt.Printf(\"add:%p, data:%+#v\\n\", &me, me) // 0xc0000644e0\n    m2 := me.WithName(\"Elliot\")\n    m2.Name()\n    fmt.Printf(\"m2 data:%+#v\\n\", m2.Name())\n}\n```","tags":["goland"],"categories":["编程语言"]}]