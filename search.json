[{"title":"根节点和stw","url":"/blog/2021/07/30/gc root&stw/","content":"*  gc roots 有哪些？\n1. 全局引用（静态变量或者常量的引用）\n2. 执行上下文（局部变量表或者本地方法栈的变量表）\n3. 跨代引用的对象，老年代对新生代的引用，记录在RSET中。\n* 什么是stw（stop the world）\nstw指的是停顿所有的用户线程，然后进行进行可达性分析。\n* 什么情况下会出现stw\n1. 枚举根节点时 必须stw\n2. 整理内存碎片时 必须进行stw，也就是标记-整理算法必须stw\n* 可达性分析包含那几部分，哪些部分必须stw。\n可达性分析可以分为枚举根节点和查找引用链两个步骤。\n枚举根节点是可达性分析准确性的基础,枚举根节点必须准确，所以必须stw。\n查找引用链是耗时最长的操作，但是可以和用户线程并发执行，不需要stw。\n* rset是什么？\nrememberset 是一种用于记录从非收集区到收集区的指针集合的数据结构。\n* 卡表、卡页和remenberset的区别和联系。\n1. rset记录了非收集区到收集区的指针集合，也就是非收集区到收集区的引用关系。但是具体实现rset是依靠卡表。\n2. 一块内存可以分成若干个卡页，每一个卡页是否存在跨代引用，使用卡表来记录。如果存在跨代引用那么就是dirty。如图所示：\n![卡表和卡页对应关系](http://assets.processon.com/chart_image/61c4bb1c1e085364150a2a38.png)\n垃圾回收时，只要筛选出卡表中 dirty的元素 即可获取到哪些卡页包含跨代引用，把这些卡页放到gc roots 中进行扫描。\n* 卡表元素如何维护呢？何时变dirty，谁来把他们变dirty？\n* 什么是伪共享，卡表是如何解决伪共享问题？\ncpu的内存是以缓冲行为单位进行传输的，如果缓存行中多个数据频繁修改，会出现大量的缓冲回写，无效化和同步操作，导致效率变低。所以建议书写的代码具有局部性原理。\n卡表如果每次写操作都更新，那么就会面临伪共享问题。如果在每次将卡表变脏前，先检查卡表是否为脏，只有不为脏的卡表才更新，可以降低伪共享的问题。\n","tags":["java"],"categories":["编程语言"]},{"title":"redis持久化","url":"/blog/2021/07/26/redis_durability/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n## 持久化\n因为redis是内存数据库，一旦服务器进程退出，那么内存的数据将会销毁。为了保存redis的内存数据，就需要一种将内存落盘的持久化手段，服务器重启后能够加载落盘后的数据来恢复服务器的状态。\n持久化的方式有RDB[快照]和AOF[日志追加]两种。\n## RDB--快照文件(恢复时间快但丢失数据多)\n### 创建RDB文件--SAVE和BGSAVE\n1. 为了防止生成RDB过程中，写入的数据干扰RDB的生成。\n**SAVE 保存EDB过程会阻塞主进程，BGSAVE通过fork子进程，父进程正常工作。**\nbgsave命令的运作流程，如下所示。\n```mermaid\ngraph TD\nA[BGSAVE] -->|1| B(父进程)\nB --> H(有其他子进程正在执行 直接返回)\nB --> |2|C(fork 父进程会阻塞)\nC -->|3| D[响应其他命令]\nC -->E[子进程]\nE -->|4| F[生成RDB默认使用LZF进行压缩]\nE -->|5通知父进程| B\n```\nRDB文件可以落盘或者通过网络发生给其他节点进行复制。\n* 在执行BGSAVE期间，服务器处理SAVE，BGSAVE和REWRITEAOF的命令与平时不同\n    1. 执行BGSAVE期间，执行SAVE和BGSAVE是会被拒绝的。因为父进程和子进程之间存在竞争条件。\n    2. BGSAVE和REWRITEAOF的命令不能同时执行。如果BGSAVE先执行，那么REWRITEAOF会延时。放过来，BGSAVE会被拒绝。\n### 加载RDB文件\n服务器载入文件的流程，如下所示\n```mermaid\ngraph TD\nA[服务器启动] -->B[执行载入程序]\nB --> C{已开启AOF持久化功能}\nC -->|是| D[载入AOF]\nC -->|否| E[载入RDB文件]\n```\n### RDB的优缺点\n* 优点\n1.  RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。\n2. Redis加载RDB恢复数据远远快于AOF的方式。\n* 缺点\n1. RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。\n2.  RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。？？？ 有哪些格式\n## AOF--独立日志方式\nAOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。主要解决数据持久化的实时性问题。\n### AOF的工作流程\nAOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载。\n\n```mermaid\ngraph TD\nA[命令写入] -->|1apend:使用文本协议| B(AOF缓冲区)\nB --> |2sync| C[AOF文件]\nC --> |重写| C\nD[重启] --> |load| C\n```\n\n* 为什么命令写到AOF缓冲区，而不是直接写入到AOF文件?\n    1. Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。\n    2. 写入缓冲区，redis就可以提供多种同步磁盘策略，也就是落盘的方案选择可以有多种。\n* AOF缓冲区同步策略有哪些？\n    1. always: 命令写入缓冲区后，立马同步硬盘。\n    2. everysec: 每秒同步一次缓冲区。\n    3. no: 有操作系统策略进行同步。\n * 为什么需要重写？解决了什么问题？\n   AOF是通过保存写命令来记录数据库的状态，但是随着写入的命令增多，文件的体积就会越来越大。AOF文件过大会造成影响redis和宿主机的性能，并且过大的AOF文件还原需要的时间也就越多。重写通过构造某个时刻数据库的状态的写入语句来减少AOF的命令数目，从而实现压缩AOF的目的。\n * 重写的原理是什么？\n    AOF的重写**不是对旧的AOF文件进行读取、分析或者写入操作，而是通过读取当前数据库的状态来实现的。**\n    假如使用了3条命令分别写入了键为key的， value分别为a b c的list，AOF的重写就是读取当前数据库的状态，重写的命令为1条 写入 key a b c的命令。\n    总之，首先从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。\n  * redis是单线程的，AOF重写如何防止阻塞主进程呢？\n    AOF的重写是后台进行的。\n    1. 发起AOF重写时，会在父进程fork子进程来进行重写，同时创建AOF重写缓冲区。\n    2. 重写后的命令会写入AOF重写缓冲区。\n      \n```mermaid\nsequenceDiagram\n客户端->>命令处理器: 发送命令\n命令处理器-->>AOF缓冲区: 追加命令\n命令处理器-->>AOF重写缓冲区: 追加命令\n```\n    \n    3. 新写入的命令，父进程处理后，会同时写入AOF缓冲区和AOF重写缓冲区，防止重写AOF时，导致数据不一致的问题。\n    4. 但子进程完成AOF重写后，会向父进程发生信号。\n    5. 父进程此时会阻塞客户端的命令，来将重写后的AOF更替成就的AOF.首先将AOF重缓冲区写入新的AOF文件，然后将AOF进行改名并覆盖旧的AOF.\n## 主从复制\n使用A服务器的客户端输入:SLAVEOF B{IP:端口} 那么A就是变成B的从服务器，B的数据也会同步到A中。也就是主服务器B会同步数据给从服务器A。\n新版的主从复制包括完全重同步和部分重同步，旧版的主从复制只有完全重同步。\n  **旧版的主从复制，如果网络闪断会进行一次完全的同步，会消耗大量的资源，导致同步时间变长。**\n  完全重同步：主要用于初次进行主从复制或者长时间断联后重新同步。主服务生成RDB文件，同时将启动生成RDB文件后的命令写入缓冲区。RDB生成后发生给从服务器，等RDB被从服务器加载完后，再将缓冲区命令发给从服务器。\n  部分重同步:主要用于网络闪断的同步恢复。从服务断联后，重新连上到主服务，如果条件允许（数据偏移量相差在一定范围），主服务会把断联期间的数据发生给从服务进行同步。\n  * 完全重同步跟旧版的复制功能几乎一样，如图。\n  \n  \n```mermaid\nsequenceDiagram\n从服务器->>主服务器: 发送SYNC\n主服务器-->>从服务器: 发送RDB\n主服务器-->>从服务器: 发送缓冲区保持的所有命令\n```\n\n  * 部分重同步\n  部分重同步主要以3部分组件实现：\n        1. 主服务器和从服务器的复制偏移量，用于检查主从服务器是否一致，从服务器是每秒发生一次心跳给主服务器同步偏移量。\n    2. 主服务器的复制积压缓冲区（默认为1M），主服务器的每条写命令都会写入复制缓冲区和从服务器。\n    3. 服务器的运行ID。\n   * 部分重同步实现步骤：\n    1. 每次主服务器向从服务器发生写命令时，会同步数据偏移量，并把写命令写入复制积压缓冲区。\n    2. 从服务器断联后，一段时间重新连接上主服务器，会向主服务发生PSYNC并报告自己的数据偏移量。\n    3. 主服务器收到从服务器的偏移量，计算目前积压缓冲区的偏移能否可以完成从服务器的同步，如果不可以那么就会进行完全同步，如果可以，就把积压缓冲区的命令发送给从服务器。\n   4. 从服务同步完数据后，更新偏移量。\n### PSYNC的工作流程\n\n```mermaid\ngraph TD\nA[从服务器接到客户端发来的SLAVEOF命令] -->B{首次复制}\nB --> |Y|C[向主服务器发送PSYNC?-1]\nB --> |N|D[向主服务器发送PSYNC <RUNID> <OFFSET>]\nC -->E[主服务器返回+FULLRESYNC<RUNID><OFFSET>执行完全重同步]\nD --> F{主服务器返回+continue}\nF -->|N| E\nF -->|Y|G[执行部分重同步] \n```\n\n\n### 主从复制过程中对过期的键的处理    \n 主从服务过程过期键的处理有特别的方式。**注意从服务器是无法自行删除过期键的，必须由主服务器触发，其实从服务器触发了惰性删除也不会执行，这样为了保持主从的一致性**，以下讲述，生成和加载RDB和AOF过程的过期键处理方式。\n 1. 生成RDB--子进程进行\n    * redis会对数据库的键进行检查，过期键不会生成RDB\n  2. 载入RDB--是否容忍键检查的时间开销\n   * 如果是主服务加载RDB，那么会对键进行检查，过期键不会加载到RDB。\n   * 如果服务是从服务器，从服务器不管是否RDB是否有过期键，都会加载到武器。\n  3. 生成AOF--是否容忍键检查的时间开销\n   * 如果数据库中存在已经过期的键，但是未被惰性或定期删除，那么也会这些过期的键也会生成到AOF文件中。\n   * 如果键被过期了，且触发了删除操作，那么AOF也会追加删除命令。\n   4. AFO重写--子进程进行\n  *  AOF重写会校验过期的键，不会写入到重写的AOF中。\n总之, 主服务器生成或加载RDB时，会忽略过期的键，因为主服务是通过子进程生成RDB的，由生成方保证数据的最新对redis服务器影响最小，并且主服务加载RDB一般是服务启动时，可以检查键过期，导致等待时间长不会造成功能问题；从服务器为了提高RDB的加载效率，尽快地进行数据同步，例如长时间断联后，进行完成重同步不能等待太久，所有不会对键的过期进行检查，直接加载RDB。生成AOF的频率比极高，不允许频繁检查键是否过期，所有会直接加载数据库的数据。AOF重写是在子进程操作，对父进程影响小，而且是进行优化目录来重写的，所有允许进行检查键是否过期。\n  * 一言蔽之，**复制过程中，是否进行键检查，取决于操作是否在子进程进行， 是否能容忍长时间的检查操作。**\n","tags":["redis"],"categories":["redis"]},{"title":"指针和值","url":"/blog/2021/07/24/pointer_value/","content":"# 指针\n## 值和指针\n值的声明直接写类型即可，如int\n指针的声明需要在类型前加*，如*int\n```\n`var v int = 1  // 开辟的一块空间，名字为v, 空间的值为1`\nvar p *int = &v  // 获取v的地址存到名为p的内存空间，*int 指向int类型的指针\n```\n![&和*的操作关系](http://assets.processon.com/chart_image/6016be58e401fd15813cfba8.png?_=1636815032732)\n## 指针操作\n* 操作符&(取址符) : 是返回该变量的内存地址\n* 操作符* (取值符) : 是返回该指针指向的变量的值, 同时也可以进行修改指针指向内存地址的值\n**取地址操作符&和取值操作符\\*是一对互补操作符**\n````\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc  TestGetAddAndVal(t *testing.T)  {\n\n    // 准备一个字符串类型\n    var house = \"Malibu Point 10880, 90265\"\n\n    // 对字符串取地址, ptr类型为*string\n    ptr := &house\n\n    // 打印ptr的类型\n    fmt.Printf(\"ptr type: %T\\n\", ptr)  // ptr type: *string\n\n    // 打印ptr的指针地址\n    fmt.Printf(\"address: %p\\n\", ptr) // address: 0xc0420401b0\n\n    // 对指针进行取值操作\n    value := *ptr\n\n    // 取值后的类型\n    fmt.Printf(\"value type: %T\\n\", value) // value type: string\n\n    // 指针取值后就是指向变量的值\n    fmt.Printf(\"value: %s\\n\", value) // value: Malibu Point 10880, 90265\n\n}\n````\n## 指针细节\n### 指针赋值\n    go 的函数和接受者都只有值传递方式，不存在引用传递。指针传递也是传递指针的地址\n    以数值交换为例\n1. 使用多重赋值进行值交换\n```\npackage main\n\nimport \"fmt\"\n\nfunc swap(a, b int) {\n    b, a = a, b\n     fmt.Println(b, a)\n         fmt.Println(&b, &a) \n}\n\nfunc main() {\n    x, y := 1, 2\n    swap(x, y)\n    fmt.Println(x, y)\n}\n```\n2. 交换指针\n```\n\npackage main\n\nimport \"fmt\"\n\nfunc swap(a, b *int) {\n    b, a = a, b\n}\n\nfunc main() {\n    x, y := 1, 2\n    swap(&x, &y)\n    fmt.Println(x, y)\n}\n```\n## 接受者指针和值\n指针不仅可以作为函数的入参和返回值，也可以作为接受者\n接收者可以为指针和值，指针会拷贝指针地址给到接收者，值会重新拷贝值给到接收者\n```\npackage pointer\n\ntype Project struct {\n    Code int\n}\nfunc (p Project) printVal() {\n    // 拷贝一个新的Project给p，不省内存\n    fmt.Printf(\"p: type:%T, add:%p\\n\", p, &p) // 地址和origin 不一样\n}\nfunc (p *Project) printProinter() {\n    // 拷贝一个新的地址给p\n    fmt.Printf(\"p: type:%T, add:%p\\n\", p, p) // 地址和origin 一样\n}\nfunc TestReceiver(t *testing.T) {\n    p := Project{}\n    fmt.Printf(\"origin p: type:%T, add:%p\\n\", p, &p)\n    p.printVal()\n    p.printProinter()\n}\n```\n*  指针接收者节省内存，，结构体很大时，性能比较好，应用运行通过指针修改变量的场景\n* 值接收者可以实现每个接收者都是全新的拷贝，可以实现不可变型的变量，提高代码的安全性，但是占用内存比较高\n\n## 实现不可变型结构体\n由于go值传递的特性，通过设置接收者的可见性为包内，并且通过值作为接受者进行拷贝新的值来实现不可变。废话不多说，直接上代码\n```\n\n// 指针 -> 修改原来地址的值\n// 值 -> 没法修改原来地址的值\n// 不可变型: 值一旦被创建就无法被改变对象,修改通过生成一个新的对象来实现\ntype Person struct {\n    name           string // 包内可见，避免被修改\n}\nfunc (p Person) WithName(newname string) Person { // 拷贝新的结构体，返回新的结构体\n    p.name = newname\n    fmt.Printf(\"WithName p's add:%p\\n\", &p) // 打印地址 0xc000064540\n    return p\n}\nfunc (p Person) Name() string { // getter\n    return p.name\n}\n// 值接收者实现不可变型\nfunc TestImmutableForm(t *testing.T) {\n    me := Person{} // 默认初始化\n    fmt.Printf(\"me data:%+#v\\n\", me.Name())\n    fmt.Printf(\"add:%p, data:%+#v\\n\", &me, me) // 0xc0000644e0\n    m2 := me.WithName(\"Elliot\")\n    m2.Name()\n    fmt.Printf(\"m2 data:%+#v\\n\", m2.Name())\n}\n```","tags":["golang"],"categories":["编程语言"]}]