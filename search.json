[{"title":"根节点和stw","url":"/blog/2021/07/30/gc%20root&stw/","content":"<ul>\n<li> gc roots 有哪些？</li>\n</ul>\n<ol>\n<li>全局引用（静态变量或者常量的引用）</li>\n<li>执行上下文（局部变量表或者本地方法栈的变量表）</li>\n<li>跨代引用的对象，老年代对新生代的引用，记录在RSET中。</li>\n</ol>\n<ul>\n<li>什么是stw（stop the world）<br>stw指的是停顿所有的用户线程，然后进行进行可达性分析。</li>\n<li>什么情况下会出现stw</li>\n</ul>\n<ol>\n<li>枚举根节点时 必须stw</li>\n<li>整理内存碎片时 必须进行stw，也就是标记-整理算法必须stw</li>\n</ol>\n<ul>\n<li>可达性分析包含那几部分，哪些部分必须stw。<br>可达性分析可以分为枚举根节点和查找引用链两个步骤。<br>枚举根节点是可达性分析准确性的基础,枚举根节点必须准确，所以必须stw。<br>查找引用链是耗时最长的操作，但是可以和用户线程并发执行，不需要stw。</li>\n<li>rset是什么？<br>rememberset 是一种用于记录从非收集区到收集区的指针集合的数据结构。</li>\n<li>卡表、卡页和remenberset的区别和联系。</li>\n</ul>\n<ol>\n<li>rset记录了非收集区到收集区的指针集合，也就是非收集区到收集区的引用关系。但是具体实现rset是依靠卡表。</li>\n<li>一块内存可以分成若干个卡页，每一个卡页是否存在跨代引用，使用卡表来记录。如果存在跨代引用那么就是dirty。如图所示：<br><img src=\"http://assets.processon.com/chart_image/61c4bb1c1e085364150a2a38.png\" alt=\"卡表和卡页对应关系\"><br>垃圾回收时，只要筛选出卡表中 dirty的元素 即可获取到哪些卡页包含跨代引用，把这些卡页放到gc roots 中进行扫描。</li>\n</ol>\n<ul>\n<li>卡表元素如何维护呢？何时变dirty，谁来把他们变dirty？</li>\n<li>什么是伪共享，卡表是如何解决伪共享问题？<br>cpu的内存是以缓冲行为单位进行传输的，如果缓存行中多个数据频繁修改，会出现大量的缓冲回写，无效化和同步操作，导致效率变低。所以建议书写的代码具有局部性原理。<br>卡表如果每次写操作都更新，那么就会面临伪共享问题。如果在每次将卡表变脏前，先检查卡表是否为脏，只有不为脏的卡表才更新，可以降低伪共享的问题。</li>\n</ul>\n","categories":["编程语言"],"tags":["java"]},{"title":"指针和值","url":"/blog/2021/07/24/pointer_value/","content":"<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"值和指针\"><a href=\"#值和指针\" class=\"headerlink\" title=\"值和指针\"></a>值和指针</h2><ul>\n<li>值的声明直接写类型即可，如int</li>\n<li>指针的声明需要在类型前加*，如 *int<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var v int = 1  // 开辟的一块空间，名字为v, 空间的值为1`</span><br><span class=\"line\">var p *int = &amp;v  // 获取v的地址存到名为p的内存空间，*int 指向int类型的指针</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"http://assets.processon.com/chart_image/6016be58e401fd15813cfba8.png?_=1636815032732\" alt=\"&amp;和*的操作关系\"></p>\n<h2 id=\"指针操作\"><a href=\"#指针操作\" class=\"headerlink\" title=\"指针操作\"></a>指针操作</h2><ul>\n<li>操作符&amp;(取址符) : 是返回该变量的内存地址</li>\n<li>操作符* (取值符) : 是返回该指针指向的变量的值, 同时也可以进行修改指针指向内存地址的值</li>\n<li><em>取地址操作符&amp;和取值操作符*是一对互补操作符</em>*<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;fmt&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func  TestGetAddAndVal(t *testing.T)  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 准备一个字符串类型</span><br><span class=\"line\">    var house = &quot;Malibu Point 10880, 90265&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对字符串取地址, ptr类型为*string</span><br><span class=\"line\">    ptr := &amp;house</span><br><span class=\"line\"></span><br><span class=\"line\">    // 打印ptr的类型</span><br><span class=\"line\">    fmt.Printf(&quot;ptr type: %T\\n&quot;, ptr)  // ptr type: *string</span><br><span class=\"line\"></span><br><span class=\"line\">    // 打印ptr的指针地址</span><br><span class=\"line\">    fmt.Printf(&quot;address: %p\\n&quot;, ptr) // address: 0xc0420401b0</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对指针进行取值操作</span><br><span class=\"line\">    value := *ptr</span><br><span class=\"line\"></span><br><span class=\"line\">    // 取值后的类型</span><br><span class=\"line\">    fmt.Printf(&quot;value type: %T\\n&quot;, value) // value type: string</span><br><span class=\"line\"></span><br><span class=\"line\">    // 指针取值后就是指向变量的值</span><br><span class=\"line\">    fmt.Printf(&quot;value: %s\\n&quot;, value) // value: Malibu Point 10880, 90265</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"指针细节\"><a href=\"#指针细节\" class=\"headerlink\" title=\"指针细节\"></a>指针细节</h2><h3 id=\"指针赋值\"><a href=\"#指针赋值\" class=\"headerlink\" title=\"指针赋值\"></a>指针赋值</h3><p>  go 的函数和接受者都只有值传递方式，不存在引用传递。指针传递也是传递指针的地址</p>\n<p>  以数值交换为例</p>\n<ol>\n<li>使用多重赋值进行值交换<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func swap(a, b int) &#123;</span><br><span class=\"line\">    b, a = a, b</span><br><span class=\"line\">     fmt.Println(b, a)</span><br><span class=\"line\">         fmt.Println(&amp;b, &amp;a) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x, y := 1, 2</span><br><span class=\"line\">    swap(x, y)</span><br><span class=\"line\">    fmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>交换指针<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func swap(a, b *int) &#123;</span><br><span class=\"line\">    b, a = a, b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    x, y := 1, 2</span><br><span class=\"line\">    swap(&amp;x, &amp;y)</span><br><span class=\"line\">    fmt.Println(x, y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"接受者指针和值\"><a href=\"#接受者指针和值\" class=\"headerlink\" title=\"接受者指针和值\"></a>接受者指针和值</h2>指针不仅可以作为函数的入参和返回值，也可以作为接受者<br>接收者可以为指针和值，指针会拷贝指针地址给到接收者，值会重新拷贝值给到接收者<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package pointer</span><br><span class=\"line\"></span><br><span class=\"line\">type Project struct &#123;</span><br><span class=\"line\">    Code int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Project) printVal() &#123;</span><br><span class=\"line\">    // 拷贝一个新的Project给p，不省内存</span><br><span class=\"line\">    fmt.Printf(&quot;p: type:%T, add:%p\\n&quot;, p, &amp;p) // 地址和origin 不一样</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p *Project) printProinter() &#123;</span><br><span class=\"line\">    // 拷贝一个新的地址给p</span><br><span class=\"line\">    fmt.Printf(&quot;p: type:%T, add:%p\\n&quot;, p, p) // 地址和origin 一样</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func TestReceiver(t *testing.T) &#123;</span><br><span class=\"line\">    p := Project&#123;&#125;</span><br><span class=\"line\">    fmt.Printf(&quot;origin p: type:%T, add:%p\\n&quot;, p, &amp;p)</span><br><span class=\"line\">    p.printVal()</span><br><span class=\"line\">    p.printProinter()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li> 指针接收者节省内存，，结构体很大时，性能比较好，应用运行通过指针修改变量的场景</li>\n<li>值接收者可以实现每个接收者都是全新的拷贝，可以实现不可变型的变量，提高代码的安全性，但是占用内存比较高</li>\n</ul>\n<h2 id=\"实现不可变型结构体\"><a href=\"#实现不可变型结构体\" class=\"headerlink\" title=\"实现不可变型结构体\"></a>实现不可变型结构体</h2><p>由于go值传递的特性，通过设置接收者的可见性为包内，并且通过值作为接受者进行拷贝新的值来实现不可变。废话不多说，直接上代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 指针 -&gt; 修改原来地址的值</span><br><span class=\"line\">// 值 -&gt; 没法修改原来地址的值</span><br><span class=\"line\">// 不可变型: 值一旦被创建就无法被改变对象,修改通过生成一个新的对象来实现</span><br><span class=\"line\">type Person struct &#123;</span><br><span class=\"line\">    name           string // 包内可见，避免被修改</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Person) WithName(newname string) Person &#123; // 拷贝新的结构体，返回新的结构体</span><br><span class=\"line\">    p.name = newname</span><br><span class=\"line\">    fmt.Printf(&quot;WithName p&#x27;s add:%p\\n&quot;, &amp;p) // 打印地址 0xc000064540</span><br><span class=\"line\">    return p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (p Person) Name() string &#123; // getter</span><br><span class=\"line\">    return p.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 值接收者实现不可变型</span><br><span class=\"line\">func TestImmutableForm(t *testing.T) &#123;</span><br><span class=\"line\">    me := Person&#123;&#125; // 默认初始化</span><br><span class=\"line\">    fmt.Printf(&quot;me data:%+#v\\n&quot;, me.Name())</span><br><span class=\"line\">    fmt.Printf(&quot;add:%p, data:%+#v\\n&quot;, &amp;me, me) // 0xc0000644e0</span><br><span class=\"line\">    m2 := me.WithName(&quot;Elliot&quot;)</span><br><span class=\"line\">    m2.Name()</span><br><span class=\"line\">    fmt.Printf(&quot;m2 data:%+#v\\n&quot;, m2.Name())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["编程语言"],"tags":["golang"]},{"title":"redis持久化","url":"/blog/2021/07/26/redis_durability/","content":"<script src=\"/js/mermaid.full.min.js\"></script>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>因为redis是内存数据库，一旦服务器进程退出，那么内存的数据将会销毁。为了保存redis的内存数据，就需要一种将内存落盘的持久化手段，服务器重启后能够加载落盘后的数据来恢复服务器的状态。<br>持久化的方式有RDB[快照]和AOF[日志追加]两种。</p>\n<h2 id=\"RDB–快照文件-恢复时间快但丢失数据多\"><a href=\"#RDB–快照文件-恢复时间快但丢失数据多\" class=\"headerlink\" title=\"RDB–快照文件(恢复时间快但丢失数据多)\"></a>RDB–快照文件(恢复时间快但丢失数据多)</h2><h3 id=\"创建RDB文件–SAVE和BGSAVE\"><a href=\"#创建RDB文件–SAVE和BGSAVE\" class=\"headerlink\" title=\"创建RDB文件–SAVE和BGSAVE\"></a>创建RDB文件–SAVE和BGSAVE</h3><ol>\n<li>为了防止生成RDB过程中，写入的数据干扰RDB的生成。</li>\n</ol>\n<p><strong>SAVE 保存EDB过程会阻塞主进程，BGSAVE通过fork子进程，父进程正常工作。</strong><br>bgsave命令的运作流程，如下所示。</p>\n<pre class=\"mermaid\">graph TD\nA[BGSAVE] -->|1| B(父进程)\nB --> H(有其他子进程正在执行 直接返回)\nB --> |2|C(fork 父进程会阻塞)\nC -->|3| D[响应其他命令]\nC -->E[子进程]\nE -->|4| F[生成RDB默认使用LZF进行压缩]\nE -->|5通知父进程| B</pre>\n<p>RDB文件可以落盘或者通过网络发生给其他节点进行复制。</p>\n<ul>\n<li>在执行BGSAVE期间，服务器处理SAVE，BGSAVE和REWRITEAOF的命令与平时不同<ol>\n<li>执行BGSAVE期间，执行SAVE和BGSAVE是会被拒绝的。因为父进程和子进程之间存在竞争条件。</li>\n<li>BGSAVE和REWRITEAOF的命令不能同时执行。如果BGSAVE先执行，那么REWRITEAOF会延时。放过来，BGSAVE会被拒绝。<h3 id=\"加载RDB文件\"><a href=\"#加载RDB文件\" class=\"headerlink\" title=\"加载RDB文件\"></a>加载RDB文件</h3>服务器载入文件的流程，如下所示<pre class=\"mermaid\">graph TD\nA[服务器启动] -->B[执行载入程序]\nB --> C{已开启AOF持久化功能}\nC -->|是| D[载入AOF]\nC -->|否| E[载入RDB文件]</pre>\n<h3 id=\"RDB的优缺点\"><a href=\"#RDB的优缺点\" class=\"headerlink\" title=\"RDB的优缺点\"></a>RDB的优缺点</h3></li>\n</ol>\n</li>\n<li>优点</li>\n</ul>\n<ol>\n<li> RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。</li>\n<li>Redis加载RDB恢复数据远远快于AOF的方式。</li>\n</ol>\n<ul>\n<li>缺点</li>\n</ul>\n<ol>\n<li>RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li>\n<li> RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。？？？ 有哪些格式<h2 id=\"AOF–独立日志方式\"><a href=\"#AOF–独立日志方式\" class=\"headerlink\" title=\"AOF–独立日志方式\"></a>AOF–独立日志方式</h2>AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。主要解决数据持久化的实时性问题。<h3 id=\"AOF的工作流程\"><a href=\"#AOF的工作流程\" class=\"headerlink\" title=\"AOF的工作流程\"></a>AOF的工作流程</h3>AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载。</li>\n</ol>\n<pre class=\"mermaid\">graph TD\nA[命令写入] -->|1apend:使用文本协议| B(AOF缓冲区)\nB --> |2sync| C[AOF文件]\nC --> |重写| C\nD[重启] --> |load| C</pre>\n\n<ul>\n<li>为什么命令写到AOF缓冲区，而不是直接写入到AOF文件?<ol>\n<li>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。</li>\n<li>写入缓冲区，redis就可以提供多种同步磁盘策略，也就是落盘的方案选择可以有多种。</li>\n</ol>\n</li>\n<li>AOF缓冲区同步策略有哪些？<ol>\n<li>always: 命令写入缓冲区后，立马同步硬盘。</li>\n<li>everysec: 每秒同步一次缓冲区。</li>\n<li>no: 有操作系统策略进行同步。</li>\n</ol>\n</li>\n<li>为什么需要重写？解决了什么问题？<br>AOF是通过保存写命令来记录数据库的状态，但是随着写入的命令增多，文件的体积就会越来越大。AOF文件过大会造成影响redis和宿主机的性能，并且过大的AOF文件还原需要的时间也就越多。重写通过构造某个时刻数据库的状态的写入语句来减少AOF的命令数目，从而实现压缩AOF的目的。</li>\n<li>重写的原理是什么？<br> AOF的重写<strong>不是对旧的AOF文件进行读取、分析或者写入操作，而是通过读取当前数据库的状态来实现的。</strong><br> 假如使用了3条命令分别写入了键为key的， value分别为a b c的list，AOF的重写就是读取当前数据库的状态，重写的命令为1条 写入 key a b c的命令。<br> 总之，首先从数据库读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</li>\n<li>redis是单线程的，AOF重写如何防止阻塞主进程呢？<br>AOF的重写是后台进行的。<ol>\n<li>发起AOF重写时，会在父进程fork子进程来进行重写，同时创建AOF重写缓冲区。</li>\n<li>重写后的命令会写入AOF重写缓冲区。</li>\n</ol>\n</li>\n</ul>\n<pre class=\"mermaid\">sequenceDiagram\n客户端->>命令处理器: 发送命令\n命令处理器-->>AOF缓冲区: 追加命令\n命令处理器-->>AOF重写缓冲区: 追加命令</pre>\n<pre><code>3. 新写入的命令，父进程处理后，会同时写入AOF缓冲区和AOF重写缓冲区，防止重写AOF时，导致数据不一致的问题。\n4. 但子进程完成AOF重写后，会向父进程发生信号。\n5. 父进程此时会阻塞客户端的命令，来将重写后的AOF更替成就的AOF.首先将AOF重缓冲区写入新的AOF文件，然后将AOF进行改名并覆盖旧的AOF.\n</code></pre>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>使用A服务器的客户端输入:SLAVEOF B{IP:端口} 那么A就是变成B的从服务器，B的数据也会同步到A中。也就是主服务器B会同步数据给从服务器A。<br>新版的主从复制包括完全重同步和部分重同步，旧版的主从复制只有完全重同步。<br>  <strong>旧版的主从复制，如果网络闪断会进行一次完全的同步，会消耗大量的资源，导致同步时间变长。</strong><br>  完全重同步：主要用于初次进行主从复制或者长时间断联后重新同步。主服务生成RDB文件，同时将启动生成RDB文件后的命令写入缓冲区。RDB生成后发生给从服务器，等RDB被从服务器加载完后，再将缓冲区命令发给从服务器。<br>  部分重同步:主要用于网络闪断的同步恢复。从服务断联后，重新连上到主服务，如果条件允许（数据偏移量相差在一定范围），主服务会把断联期间的数据发生给从服务进行同步。</p>\n<ul>\n<li>完全重同步跟旧版的复制功能几乎一样，如图。</li>\n</ul>\n<pre class=\"mermaid\">sequenceDiagram\n从服务器->>主服务器: 发送SYNC\n主服务器-->>从服务器: 发送RDB\n主服务器-->>从服务器: 发送缓冲区保持的所有命令</pre>\n\n<ul>\n<li>部分重同步<br>部分重同步主要以3部分组件实现：<pre><code>1. 主服务器和从服务器的复制偏移量，用于检查主从服务器是否一致，从服务器是每秒发生一次心跳给主服务器同步偏移量。\n</code></pre>\n<ol start=\"2\">\n<li>主服务器的复制积压缓冲区（默认为1M），主服务器的每条写命令都会写入复制缓冲区和从服务器。</li>\n<li>服务器的运行ID。</li>\n</ol>\n</li>\n<li>部分重同步实现步骤：    1. 每次主服务器向从服务器发生写命令时，会同步数据偏移量，并把写命令写入复制积压缓冲区。    2. 从服务器断联后，一段时间重新连接上主服务器，会向主服务发生PSYNC并报告自己的数据偏移量。    3. 主服务器收到从服务器的偏移量，计算目前积压缓冲区的偏移能否可以完成从服务器的同步，如果不可以那么就会进行完全同步，如果可以，就把积压缓冲区的命令发送给从服务器。</li>\n</ul>\n<ol start=\"4\">\n<li>从服务同步完数据后，更新偏移量。<h3 id=\"PSYNC的工作流程\"><a href=\"#PSYNC的工作流程\" class=\"headerlink\" title=\"PSYNC的工作流程\"></a>PSYNC的工作流程</h3></li>\n</ol>\n<pre class=\"mermaid\">graph TD\nA[从服务器接到客户端发来的SLAVEOF命令] -->B{首次复制}\nB --> |Y|C[向主服务器发送PSYNC?-1]\nB --> |N|D[向主服务器发送PSYNC <RUNID> <OFFSET>]\nC -->E[主服务器返回+FULLRESYNC<RUNID><OFFSET>执行完全重同步]\nD --> F{主服务器返回+continue}\nF -->|N| E\nF -->|Y|G[执行部分重同步]</pre>\n\n\n<h3 id=\"主从复制过程中对过期的键的处理\"><a href=\"#主从复制过程中对过期的键的处理\" class=\"headerlink\" title=\"主从复制过程中对过期的键的处理\"></a>主从复制过程中对过期的键的处理</h3><p> 主从服务过程过期键的处理有特别的方式。<strong>注意从服务器是无法自行删除过期键的，必须由主服务器触发，其实从服务器触发了惰性删除也不会执行，这样为了保持主从的一致性</strong>，以下讲述，生成和加载RDB和AOF过程的过期键处理方式。</p>\n<ol>\n<li>生成RDB–子进程进行<ul>\n<li>redis会对数据库的键进行检查，过期键不会生成RDB</li>\n</ul>\n</li>\n<li>载入RDB–是否容忍键检查的时间开销</li>\n</ol>\n<ul>\n<li>如果是主服务加载RDB，那么会对键进行检查，过期键不会加载到RDB。</li>\n<li>如果服务是从服务器，从服务器不管是否RDB是否有过期键，都会加载到武器。</li>\n</ul>\n<ol start=\"3\">\n<li>生成AOF–是否容忍键检查的时间开销</li>\n</ol>\n<ul>\n<li>如果数据库中存在已经过期的键，但是未被惰性或定期删除，那么也会这些过期的键也会生成到AOF文件中。</li>\n<li>如果键被过期了，且触发了删除操作，那么AOF也会追加删除命令。</li>\n</ul>\n<ol start=\"4\">\n<li>AFO重写–子进程进行</li>\n</ol>\n<ul>\n<li> AOF重写会校验过期的键，不会写入到重写的AOF中。<br>总之, 主服务器生成或加载RDB时，会忽略过期的键，因为主服务是通过子进程生成RDB的，由生成方保证数据的最新对redis服务器影响最小，并且主服务加载RDB一般是服务启动时，可以检查键过期，导致等待时间长不会造成功能问题；从服务器为了提高RDB的加载效率，尽快地进行数据同步，例如长时间断联后，进行完成重同步不能等待太久，所有不会对键的过期进行检查，直接加载RDB。生成AOF的频率比极高，不允许频繁检查键是否过期，所有会直接加载数据库的数据。AOF重写是在子进程操作，对父进程影响小，而且是进行优化目录来重写的，所有允许进行检查键是否过期。</li>\n<li>一言蔽之，<strong>复制过程中，是否进行键检查，取决于操作是否在子进程进行， 是否能容忍长时间的检查操作。</strong></li>\n</ul>\n","categories":["redis"],"tags":["redis"]}]